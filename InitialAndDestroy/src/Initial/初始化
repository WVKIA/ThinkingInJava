一个类被使用，从加载到JVM，到卸出内存，整个生命周期： 加载 -- 》 验证 -- 》 准备 --  》 解析 -- 》 初始化 -- 》 使用 -- 》卸载

什么时候一个类会被加载：
    1、遇到 new（本质也是调用static方法）、读取或设置类的静态字段（被static final修改的不算，因为这些已经被放到方法区，不需要加载类也可以读取）（直接所在类）
            、以及调用类的静态方法 的时候
    2、使用 Java.lang.reflect反射对类进行调用，例如class.forName()，
    3、当初始化一个类，发现父类没有初始化，会先触发父类的初始化
    4、虚拟机启动的那个类，main方法所在的类
    5、Method.invoke()方法调用时，方法所在类会被初始化


各个周期的动作以及初始化内容：
    加载 --  》
        加载需要完成三件事：
            1、通过类的全限定名获取定义此类的二进制流
            2、把二进制流的存储结构数据转成方法去的运行时数据
            3、内存中生成一个代表这个类的Class对象，（存放在方法区），作为方法区这个类各个数据结构的访问入口
    验证 -- 》
        验证字节流是否正确
     准备 -- 》
        为类变量分配内存并设置初始值，这个类变量就是static变量，而不是实例变量，分配内存并设置初始值，就是每个类型的初始值，基本类型是0，对象是null
        但对于staic final会被直接初始化对应的值
         类变量使用的内存都是在方法区（*）
     解析 --  》

      初始化 -- 》

      <clinit>对静态成员和代码初始化，<init>是instance实例构造器，对非静态常量初始化

       <clinit>收集的是类构造器，即静态代码和块，顺序按代码顺序来
       <init>收集的是实例构造器，非静态，将变量初始化、调用父类构造器等收敛到init方法中，具体顺序是
            父类的 变量初始化和语句块，按顺序，然后是父类的构造器
            其次是子类的变量初始化和语句块，按顺序，然后是构造器

        这个阶段才是真正开始执行类中定义的Java程序代码，执行类构造器<clinit>方法，<clinit>是由编译器自动收集 所有 类变量即static的赋值语句和静态代码块，按顺序
        JVM会保证 父类的<clinit>在子类之前，所以父类的静态代码执行会先于子类的静态，
        然后是如果遇到构造器（也是static）

以上就是类加载过程中全部实例内存分配和赋值顺序，注意子类构造父类时，父类调用方法多态的问题